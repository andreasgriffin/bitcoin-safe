name: Build and Test MacOS DMG
permissions:
  contents: read


on:
  workflow_dispatch:
    inputs:
      commitHash:
        description: 'Enter the commit hash to build (leave empty to use the default branch or the branch that triggered the workflow)'
        required: false
        type: string
      skip_build_and_test_release_tag:
        description: 'Release tag to download prebuilt macOS artifacts instead of building (leave empty to build)'
        required: false
        default: ''
        type: string
  workflow_call:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        # Building on macos-14 produces an arm64 DMG,
        # and building on macos-15-intel produces an x86 DMG.
        # see available: https://github.com/actions/runner-images?tab=readme-ov-file#available-images
        include:
          - os: macos-14
            artifact_name: dmgs-arm64
            arch: arm64
          - os: macos-15-intel
            artifact_name: dmgs-x86_64
            arch: x86_64
    steps:
      # 1) clone the default branch with full history
      - name: Checkout default branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2) if a SHA was provided, fetch it and switch to it
      - name: Fetch and checkout custom commit
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.commitHash != '' }}
        run: |
          # this will succeed as long as the commit is reachable from ANY branch on the remote
          git fetch origin ${{ github.event.inputs.commitHash }}
          git checkout ${{ github.event.inputs.commitHash }}           

      # Use the build path for all non-dispatch events, or dispatch events that did not request a prebuilt release download.
      # When skip_build_and_test_release_tag is non-empty on workflow_dispatch, the release-download path is used instead.
      - name: Set up Python environment
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_build_and_test_release_tag == '' }}
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Python dependencies
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_build_and_test_release_tag == '' }}
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Run build script
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_build_and_test_release_tag == '' }}
        run: poetry run python tools/build.py --targets mac --commit None

      - name: Check for DMG file
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_build_and_test_release_tag == '' }}
        run: |
          if [ -z "$(find dist -type f -name '*.dmg')" ]; then
            echo "DMG file is missing"
            exit 1
          fi

      - name: Upload DMG Files from dist/
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_build_and_test_release_tag == '' }}
        uses: actions/upload-artifact@v4
        with:
          name: mac-artifact-${{ matrix.artifact_name }}
          path: dist/*.dmg

  test:
    needs: build
    strategy:
      matrix:
        include:
          - arch: arm64
            runner: macos-15  # This runner must be an arm64 machine
            artifact_name: dmgs-arm64
          - arch: x86_64
            runner: macos-15-intel    # This runner must be an x86 machine
            artifact_name: dmgs-x86_64
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Download DMG Artifact for ${{ matrix.arch }}
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_build_and_test_release_tag == '' }}
        uses: actions/download-artifact@v4
        with:
          name: mac-artifact-${{ matrix.artifact_name }}
          path: dmgs

      - name: Download release DMG for ${{ matrix.arch }}
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.skip_build_and_test_release_tag != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          mkdir -p dmgs
          gh release download "${{ github.event.inputs.skip_build_and_test_release_tag }}" \
            --dir dmgs \
            --repo "${{ github.repository }}" \
            --pattern "*-${{ matrix.arch }}.dmg"
          shopt -s nullglob
          for archive in dmgs/*.zip; do
            unzip -o "$archive" -d dmgs
          done
          for archive in dmgs/*.tar.gz dmgs/*.tgz; do
            tar -xzf "$archive" -C dmgs
          done
          if ! find dmgs -type f -name '*.dmg' -print -quit | grep -q .; then
            echo "DMG not found in downloaded release artifacts"
            exit 1
          fi

      - name: Start DMG file on ${{ matrix.arch }}
        run: |
          set -euo pipefail

          find_app_pids() {
            pgrep -f "/Bitcoin Safe.app/Contents/MacOS/Bitcoin Safe" || true
          }

          wait_for_pid_to_exit() {
            target_pid="$1"
            timeout_seconds="$2"
            for _ in $(seq 1 "$timeout_seconds"); do
              if ! kill -0 "$target_pid" 2>/dev/null; then
                return 0
              fi
              sleep 1
            done
            return 1
          }

          wait_for_new_pid() {
            old_pid="$1"
            timeout_seconds="$2"
            for _ in $(seq 1 "$timeout_seconds"); do
              for pid in $(find_app_pids); do
                if [ "$pid" != "$old_pid" ]; then
                  echo "$pid"
                  return 0
                fi
              done
              sleep 1
            done
            return 1
          }

          # Find the DMG file from the downloaded artifacts.
          DMG_FILE=$(find dmgs -type f -name '*.dmg' | head -n 1)
          if [ -z "$DMG_FILE" ]; then
            echo "No DMG file found to test."
            exit 1
          fi
          echo "Found DMG file: $DMG_FILE" | tee test_dmg.log

          # Mount the DMG.
          echo "Mounting DMG file..." | tee -a test_dmg.log
          i=0
          until MOUNT_OUTPUT=$(hdiutil attach "$DMG_FILE" 2>&1); do
            if [ $i -eq 10 ]; then
              echo "Could not attach DMG" | tee -a test_dmg.log
              exit 1
            fi
            i=$((i+1))
            sleep 1
          done
          echo "$MOUNT_OUTPUT" | tee -a test_dmg.log

          # Extract the mount point (preserving spaces in volume name).
          MOUNT_POINT=$(echo "$MOUNT_OUTPUT" \
            | grep '/Volumes/' \
            | cut -f3- -d $'\t')
          if [ -z "$MOUNT_POINT" ]; then
            echo "Failed to mount DMG file" | tee -a test_dmg.log
            exit 1
          fi
          echo "DMG mounted at: $MOUNT_POINT" | tee -a test_dmg.log

          # Find the .app bundle within the mounted DMG.
          APP_PATH=$(find "$MOUNT_POINT" -maxdepth 1 -name '*.app' | head -n 1)
          if [ -z "$APP_PATH" ]; then
            echo "No .app found in mounted DMG" | tee -a test_dmg.log
            exit 1
          fi
          echo "Found app at: $APP_PATH" | tee -a test_dmg.log

          # Launch the app.
          LOG_DIR="$HOME/Library/Application Support/bitcoin_safe"

          if [ -d "$LOG_DIR" ]; then
            echo "Removing pre-existing bitcoin_safe logs under $LOG_DIR" | tee -a test_dmg.log
            rm -f "$LOG_DIR"/bitcoin_safe.log* || true
          fi

          echo "Launching app via open" | tee -a test_dmg.log
          open "$APP_PATH"

          # Take screenshots.
          echo "Starting screenshot capture..." | tee -a test_dmg.log
          for i in $(seq 1 20); do
            echo "Taking screenshot $i" | tee -a test_dmg.log
            screencapture -x "screenshot_$i.png"
            sleep 1
          done

          # Verify the app is running.
          echo "Checking if Bitcoin Safe is running..." | tee -a test_dmg.log
          PROCESS_COUNT=$(ps aux | grep -v grep | grep "Bitcoin Safe" | wc -l)
          if [ "$PROCESS_COUNT" -eq 0 ]; then
            echo "Error: Bitcoin Safe is not running!" | tee -a test_dmg.log
            exit 1
          else
            echo "Bitcoin Safe is running." | tee -a test_dmg.log
          fi

          # Capture a baseline PID and verify restart via the Network Settings UI.
          INITIAL_PID=$(find_app_pids | head -n 1)
          if [ -z "$INITIAL_PID" ]; then
            echo "Could not determine initial app PID before restart test." | tee -a test_dmg.log
            exit 1
          fi
          echo "Initial app PID: $INITIAL_PID" | tee -a test_dmg.log

          echo "Opening Network Settings and clicking 'Apply and restart'..." | tee -a test_dmg.log
          osascript <<'APPLESCRIPT'
          tell application "Bitcoin Safe" to activate
          delay 1
          tell application "System Events"
            tell process "Bitcoin Safe"
              set frontmost to true
              keystroke "," using command down
            end tell
          end tell
          APPLESCRIPT

          # Wait until the settings dialog is available, then click Apply and restart.
          for i in $(seq 1 20); do
            if osascript <<'APPLESCRIPT'
            tell application "System Events"
              tell process "Bitcoin Safe"
                if exists (window "Network Settings") then
                  click button "Apply and restart" of window "Network Settings"
                  return "clicked"
                end if
              end tell
            end tell
            APPLESCRIPT
            then
              echo "Clicked Apply and restart." | tee -a test_dmg.log
              break
            fi
            if [ "$i" -eq 20 ]; then
              echo "Network Settings dialog or Apply and restart button not found." | tee -a test_dmg.log
              exit 1
            fi
            sleep 1
          done

          # If server checks fail, a confirmation dialog can appear; accept it.
          osascript <<'APPLESCRIPT' || true
          tell application "System Events"
            tell process "Bitcoin Safe"
              repeat 5 times
                try
                  if exists button "Yes" of window 1 then
                    click button "Yes" of window 1
                    exit repeat
                  end if
                end try
                delay 1
              end repeat
            end tell
          end tell
          APPLESCRIPT

          if wait_for_pid_to_exit "$INITIAL_PID" 90; then
            echo "Old process exited as expected." | tee -a test_dmg.log
          else
            echo "Old process (PID $INITIAL_PID) did not exit after restart request." | tee -a test_dmg.log
            exit 1
          fi

          NEW_PID=$(wait_for_new_pid "$INITIAL_PID" 90 || true)
          if [ -z "$NEW_PID" ]; then
            echo "No new process detected after restart request." | tee -a test_dmg.log
            exit 1
          fi
          echo "Detected restarted app with new PID: $NEW_PID" | tee -a test_dmg.log

          # Confirm the app process remains alive after restart.
          sleep 5
          if ! kill -0 "$NEW_PID" 2>/dev/null; then
            echo "Restarted process exited unexpectedly (PID $NEW_PID)." | tee -a test_dmg.log
            exit 1
          fi
          echo "Restart verification succeeded." | tee -a test_dmg.log
        shell: bash


      - name: Check for pyzbar log entry in bitcoin_safe.log
        run: |
          LOG_PATH="$HOME/Library/Application Support/bitcoin_safe/bitcoin_safe.log"
          echo "Checking bitcoin_safe.log for 'pyzbar could be loaded successfully' at $LOG_PATH..." | tee -a test_dmg.log
          if ! grep -q "pyzbar could be loaded successfully" "$LOG_PATH"; then
            echo "Error: 'pyzbar could be loaded successfully' not found in bitcoin_safe.log" | tee -a test_dmg.log
            exit 1
          fi
                
      - name: Gatekeeper tests on ${{ matrix.arch }}
        run: |
          echo "Starting DMG Gatekeeper tests..." | tee test_dmg.log
          
          # Locate the DMG file
          DMG_FILE=$(find dmgs -type f -name '*.dmg' | head -n 1)
          if [ -z "$DMG_FILE" ]; then
            echo "No DMG file found to test." | tee -a test_dmg.log
            exit 1
          fi
          echo "Found DMG file: $DMG_FILE" | tee -a test_dmg.log
          
          #######################################################
          # Gatekeeper check on the DMG
          #######################################################
          echo "Running Gatekeeper check on DMG..." | tee -a test_dmg.log
          OUTPUT=$(spctl --assess --verbose "$DMG_FILE" 2>&1) || true
          echo "$OUTPUT" | tee -a test_dmg.log
          if echo "$OUTPUT" | grep -Eq "(invalid signature)"; then
            echo "DMG has invalid signature" | tee -a test_dmg.log
            exit 1
          fi
          
          #######################################################
          # Attach the DMG (with retry logic)
          #######################################################
          echo "Mounting DMG file with retry logic..." | tee -a test_dmg.log
          i=0
          until MOUNT_OUTPUT=$(hdiutil attach "$DMG_FILE" 2>&1); do
            if [ $i -eq 10 ]; then
              echo "Could not attach DMG" | tee -a test_dmg.log
              exit 1
            fi
            i=$((i+1))
            sleep 1
          done
          echo "$MOUNT_OUTPUT" | tee -a test_dmg.log
          
          # Extract the mount point (preserving spaces in volume name)
          MOUNT_POINT=$(echo "$MOUNT_OUTPUT" \
            | grep '/Volumes/' \
            | cut -f3- -d $'\t')
          if [ -z "$MOUNT_POINT" ]; then
            echo "Failed to identify DMG mount point" | tee -a test_dmg.log
            exit 1
          fi
          echo "DMG mounted at: $MOUNT_POINT" | tee -a test_dmg.log
          
          #######################################################
          # Copy .app bundle out of the DMG
          #######################################################
          APP_PATH=$(find "$MOUNT_POINT" -maxdepth 1 -name '*.app' | head -n 1)
          if [ -z "$APP_PATH" ]; then
            echo "No .app found in mounted DMG" | tee -a test_dmg.log
            exit 1
          fi
          echo "Found app at: $APP_PATH" | tee -a test_dmg.log
          cp -R "$APP_PATH" ./
          APP_BASENAME=$(basename "$APP_PATH")
          echo "Copied $APP_BASENAME to local directory" | tee -a test_dmg.log
          
          #######################################################
          # Gatekeeper check on the .app bundle
          #######################################################
          echo "Running Gatekeeper check on .app..." | tee -a test_dmg.log
          OUTPUT=$(spctl --assess --verbose "$APP_BASENAME" 2>&1) || true
          echo "$OUTPUT" | tee -a test_dmg.log
          if echo "$OUTPUT" | grep -Eq "(invalid signature)"; then
            echo "App has invalid signature" | tee -a test_dmg.log
            exit 1
          fi



      - name: Upload DMG and Application Logs for ${{ matrix.arch }}
        if: always()  # This ensures the step runs regardless of previous failures    
        uses: actions/upload-artifact@v4
        with:
          name: mac-tests-${{ matrix.arch }}
          path: |
            *.png
            *.log
            /Users/runner/Library/Application Support/bitcoin_safe/*
